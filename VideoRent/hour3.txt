now we are going to get our data from  db using entity framework

entity framework is a tool we use to access the db

more accurately its classified as orm


in old days we had to do this mapping manually which involved opening a connection to db

with orm we work at a higher level abstraction


it provides a class called dbContext	

dbContext has one or more dbSet 's which represents tables in our db	

we use linq to query these db sets

and entity framework will translate our linq queries to sql at run time

it opens the db maps the data


there are two ways to use entity framwork

db first and code first

***************** dbFirst workflow

in this we generate the corresponding domain classes after creation of database tables



***************** the other way is to create domain classes first and let the entity framework create the db tables for us


i personally favor code first to db first

increased productivity

full versioning of db using migrations

much easier to build an integration test db		

myth :
1 code first work flow on legacy db can be used very efficiently
2 it gives you full control over db



in code first we start with code everytime we modify our domain model
we create a migration and run it on the db

let me show you how it works


package manager console alt + .

first time you need to enable them

when you type 

enable-migrations

now you see a new folder migrations


lets add first migration

since this is a first change i am gonna call it initial model


under this c sharp 

we will see 

aspNetRoles
aspNetUserRoles
aspNetUsers


so where these tables are coming from 

weill this is a part of asp.net identity
which our projects uses to control authentication and authorization


let me show you something

expand models => identity models


here we have two classes 
application user

and application Db context

which der from identitydbContext

this is a gateway to our db



this identitydbContext is a part of asp.net identity framwork


so when i executed add migration 

it looked at our applicationdbContext

and it discovered dbSets in identityDbContext

here we are had all the user

that is why in our call we had created these tables


now we do not see any db sets for movies and customers
so i go back to our identityModels


so this dbSet represennt Customer table in our database

now i go back to our console and create our migration

since it is already there is am gonna use --force swith to override it

add-migration intitialModel -force

lets reload

now lets go back to our migration class

so here we see and attempt to create table with the following names

now lets run this migration and generate our db


cls

update-databse



if i go under show files
we go under appdata
we got this database file lets double click it

so here is our db

we got our tables

so we have tables asp.net which are used for controlling authentication and authorization

we also have customers table with id and name

there is one more table here which we should not touch called migration history



************************************ changing the model ***********

our dommain model is very simple here so will add new props


customer => name, isSubscribedToNewsLetter, MembershipType

membership => payAsYouGo 

monthly =>  $30       10%
quaterly => $90       15%
annual =>   $300      20%


so model this we need a membership type signupfee, duration, discountRate

each customer should have only one and one membership type


when following for code first 

instead of making changes in one go 

we should make changes in small parts

and run small migrations

so back to customers and add

name, bool isSubscribedtoNews

we can name it AddIsSubscribedToCustomer

migration created 
now update-database

now going back to Model

add a new class MembershipType

for signup fee we gonna use short

for durationInMonths

for discountRate lets use byte


lets use byte for id as we have only few membership type

now we need to associate our customer class with membership type

we go to our Customer class 

and add public MembershipType MembershipType {get; set;}


this navigation property is useful when you want to load and object and its related object from db

sometimes for optimization we dont want to load the entire membership object

for that you may need a foreign key

public byte MembershipTypeId

entity framewrk recognises this as a foreign key



now we need to add a migration





******       seeding the database
now if we see under db member ship types

currently this table is empty and we need to populate this table with some records

so our dev, test and prod should have exact same membership types

	
so to make this consistency, 
but we never touch db in code first

everychange in db should go through migration


so we are not supposed to open this table and insert few records

so we use a migration, 
i am gonna add a migration, and call it PopulateMembershipTypes


so its an empty migration

by going in up()

we can add 


Sql("Insert into MembershipTypes (Id, SignUpFee, DurationInMonths, DiscountRates) Values (1,0,0,0)")

we can do ctrl +d 

Sql("Insert into MembershipTypes (Id, SignUpFee, DurationInMonths, DiscountRates) Values (1,0,0,0)")
Sql("Insert into MembershipTypes (Id, SignUpFee, DurationInMonths, DiscountRates) Values (2,30,1,10)")
Sql("Insert into MembershipTypes (Id, SignUpFee, DurationInMonths, DiscountRates) Values (3,90,3,15)")
Sql("Insert into MembershipTypes (Id, SignUpFee, DurationInMonths, DiscountRates) Values (4,300,12,20)")


so with code first we do have full  control on db

we can run any query


now we run this migration
update-database


while time of depoying our application we can give all this database from beginning of time to last

and using a cmd in pmc we can generate a sql script to include all these changes

so with code first work flow we have full control over versioning of our database

in the next we will talk about overriding code first conventions


*********** overriding conventions **********


the name is set by entity framwork as nullable

now lets see how we can over ride these default conventions


in our model class customer

above the property 

we define the annotation called 
[Required]
public string Name {get; set;}


with this our customer name will no longer be nullable
[StringLength(255)]


this approach is called annotations

but it has some limitations


now we have create a new migration

as we have changed our domain model
add-migration ApplyAnnotationstoCustomerName	

next we are gonna take a look at how to query objects using entity framework

